import itertools
import collections

from apriori.rule import Rule


def create_items(baskets):
    """
    Given a set of baskets, create unique set of singleton elements.

    :param baskets:
    :return:
    """
    items = set()
    for basket in baskets:
        for item in basket:
            items.add(frozenset({item}))
    return items


def generate_candidates(prev_candidates, singletons):
    """
   Candidates in Ck can be generated by combining itemsets from Lk-1 and singletons from L1.

    One should be careful and selective with candidate generation: for a candidate in Ck to be a frequent itemset,
    all its subsets must be frequent, not only the itemsets from Lk-1 and L1 that the candidate is constructed from,
    i.e., each of its subsets should be in the corresponding Lm, m = 1,â€¦, k-1
   :param prev_candidates:
   :param singletons:
   :return:
   """
    k = len(next(iter(prev_candidates)))+1  # Extract the size of an element from prev to calculate the current iteration.

    m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
    candidates = set()

    for candidate in prev_candidates:
        for i in singletons:
            mismatch = False
            new_candidate = frozenset(candidate).union(i)
            for combination in itertools.combinations(candidate, m):
                frequent_tuple = frozenset(combination).union(i)
                if frequent_tuple not in prev_candidates:
                    mismatch = True
                    break
            if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)

    return candidates


def prune_candidates(candidates, s, baskets):
    occurrences = collections.Counter()
    n = len(baskets)

    for basket in baskets:
        for candidate in candidates:
            if candidate.issubset(basket):
                occurrences[candidate] += 1

    candidates_return = candidates.copy()
    support_return = dict()
    for candidate, occurrence in occurrences.items():
        support = occurrence/n
        if support < s:
            candidates_return.discard(candidate)
        else:
            support_return[candidate] = support

    return candidates_return, support_return


def find_frequent_itemsets(baskets, support):
    frequent_itemsets = set()
    support_itemsets = dict()

    c1 = create_items(baskets)
    l1, support_l1 = prune_candidates(c1, support, baskets)

    frequent_itemsets = frequent_itemsets.union(l1)
    support_itemsets.update(support_l1)

    current = c1

    while len(current) > 0:
        ck = generate_candidates(current, c1)
        lk, support_lk = prune_candidates(ck, support, baskets)

        frequent_itemsets = frequent_itemsets.union(lk)
        support_itemsets.update(support_lk)
        current = lk

    return frequent_itemsets, support_itemsets


def generation_rules(c, itemset, support_itemset):
    def _generation_rules(candidate_rule):
        if len(candidate_rule.antecedent) == 0 :
            return

        if candidate_rule.confidence >= c or len(candidate_rule.consequent) == 0:  # second condition for {a,b,c} -> {}
            if len(candidate_rule.consequent) > 0: rules.add(candidate_rule)

            for i in candidate_rule.antecedent:
                new_antecedent = candidate_rule.antecedent.difference({i})
                new_consequent = candidate_rule.consequent.union({i})
                if len(new_antecedent) == 0:  # next iteration -> {} -> {a,b,c}
                    new_confidence = 0
                else:
                    new_confidence = candidate_rule.confidence / support_itemset[new_antecedent]

                _generation_rules(Rule(new_confidence, new_antecedent, new_consequent))
        return

    candidate_confidence = support_itemset[itemset]
    candidate_rule = Rule(candidate_confidence, itemset)
    rules = set()
    _generation_rules(candidate_rule)

    return rules


if __name__ == "__main__":
    baskets = [[1, 2, 3, 5], [2, 5, 3], [2, 5, 4, 1, 1]]
    support = 0.5

    frequent_itemsets, support_itemsets = find_frequent_itemsets(baskets, support)
    print(frequent_itemsets)
    print(support_itemsets)

    rules = generation_rules(0.8, frozenset({1, 2, 5}), support_itemsets)
    for r in rules:
        print(r)






# def generate_candidates_from_previous_candidates(k ,prev_candidates):
#     m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
#     candidates = set()
#
#     for candidate in prev_candidates:
#         for rest in prev_candidates:
#             for i in rest:
#                 mismatch = False
#                 new_candidate = frozenset(candidate).union({i})
#                 for combination in itertools.combinations(candidate, m):
#                     frequent_tuple = frozenset(combination).union({i})
#                     if frequent_tuple not in prev_candidates:
#                         mismatch = True
#                 if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)
#
#     return candidates

