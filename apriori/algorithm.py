import itertools
import collections


def create_items(baskets):
    """
    Given a set of baskets, create unique set of singleton elements.

    :param baskets:
    :return:
    """
    items = set()
    for basket in baskets:
        for item in basket:
            items.add(frozenset({item}))
    return items


def generate_candidates(prev_candidates, singletons):
    """
   Candidates in Ck can be generated by combining itemsets from Lk-1 and singletons from L1.

    One should be careful and selective with candidate generation: for a candidate in Ck to be a frequent itemset,
    all its subsets must be frequent, not only the itemsets from Lk-1 and L1 that the candidate is constructed from,
    i.e., each of its subsets should be in the corresponding Lm, m = 1,â€¦, k-1
   :param prev_candidates:
   :param singletons:
   :return:
   """
    k = len(next(iter(prev_candidates)))+1  # Extract the size of an element from prev to calculate the current iteration.

    m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
    candidates = set()

    for candidate in prev_candidates:
        for i in singletons:
            mismatch = False
            new_candidate = frozenset(candidate).union(i)
            for combination in itertools.combinations(candidate, m):
                frequent_tuple = frozenset(combination).union(i)
                if frequent_tuple not in prev_candidates:
                    mismatch = True
                    break
            if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)

    return candidates


def prune_candidates(candidates, support, baskets):
    occurrences = collections.Counter()
    n = len(baskets)

    for basket in baskets:
        for candidate in candidates:
            if candidate.issubset(basket):
                occurrences[candidate] += 1

    candidates_return = candidates.copy()
    for candidate, occurrence in occurrences.items():
        if occurrence/n < support:
            candidates_return.discard(candidate)

    return candidates_return


def find_frequent_itemsets(baskets, support):
    c1 = create_items(baskets)
    l1 = current = prune_candidates(c1, support, baskets)

    frequent_itemsets = set()
    frequent_itemsets = frequent_itemsets.union(l1)

    while len(current) > 0:
        ck = generate_candidates(current, c1)
        lk = prune_candidates(ck, support, baskets)

        frequent_itemsets = frequent_itemsets.union(lk)
        current = lk

    return frequent_itemsets


if __name__ == "__main__":
    baskets = [[1, 2, 3, 5], [2, 5, 3], [2, 5, 4, 1, 1]]
    support = 0.5

    print(find_frequent_itemsets(baskets, support))




# def generate_candidates_from_previous_candidates(k ,prev_candidates):
#     m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
#     candidates = set()
#
#     for candidate in prev_candidates:
#         for rest in prev_candidates:
#             for i in rest:
#                 mismatch = False
#                 new_candidate = frozenset(candidate).union({i})
#                 for combination in itertools.combinations(candidate, m):
#                     frequent_tuple = frozenset(combination).union({i})
#                     if frequent_tuple not in prev_candidates:
#                         mismatch = True
#                 if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)
#
#     return candidates

