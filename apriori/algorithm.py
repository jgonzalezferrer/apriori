import itertools
def create_items(baskets):
    """
    Given a set of baskets, create unique set of singleton elements.

    :param baskets:
    :return:
    """
    items = set()
    for basket in baskets:
        for item in basket:
            items.add(frozenset({item}))
    return items


def generate_candidates(prev_candidates, singletons):
    """
   Candidates in Ck can be generated by combining itemsets from Lk-1 and singletons from L1.

    One should be careful and selective with candidate generation: for a candidate in Ck to be a frequent itemset,
    all its subsets must be frequent, not only the itemsets from Lk-1 and L1 that the candidate is constructed from,
    i.e., each of its subsets should be in the corresponding Lm, m = 1,â€¦, k-1
   :param prev_candidates:
   :param singletons:
   :return:
   """
    k = len(next(iter(prev_candidates)))+1  # Extract the size of an element from prev to calculate the current iteration.

    m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
    candidates = set()

    for candidate in prev_candidates:
        for i in singletons:
            mismatch = False
            new_candidate = frozenset(candidate).union(i)
            for combination in itertools.combinations(candidate, m):
                frequent_tuple = frozenset(combination).union(i)
                if frequent_tuple not in prev_candidates:
                    mismatch = True
                    break
            if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)

    return candidates


# def generate_candidates_from_previous_candidates(k ,prev_candidates):
#     m = k - 2 if k > 1 else 0  # Base case k = 1, ignore: used for check subsets are frequent itemsets.
#     candidates = set()
#
#     for candidate in prev_candidates:
#         for rest in prev_candidates:
#             for i in rest:
#                 mismatch = False
#                 new_candidate = frozenset(candidate).union({i})
#                 for combination in itertools.combinations(candidate, m):
#                     frequent_tuple = frozenset(combination).union({i})
#                     if frequent_tuple not in prev_candidates:
#                         mismatch = True
#                 if not mismatch and len(new_candidate) == k: candidates.add(new_candidate)
#
#     return candidates

